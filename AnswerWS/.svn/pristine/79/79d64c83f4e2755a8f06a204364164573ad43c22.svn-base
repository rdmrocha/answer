#include <stdlib.h>
#include <string>
#include <stdexcept>
#include <iostream>

#include <dlfcn.h>
#include <axis2_module.h>
#include <axutil_allocator.h>
#include <axis2_conf_ctx.h>

#include <axis2_handler.h>

#include "anubis/webservice/WebModule.hh"
#include "anubis/webservice/Environment.hh"
#include "AxisEnvironmentWrapper.hh"
#include "AxisCookieWrapper.hh"
#include "anubis/webservice/XmlParams.hh"

#include <glob.h>

using namespace std;
using namespace anubis::webservice;

class AxisOperation: public OperationInfo {
    string _full_name;
    string _service_name;
    string _operation_name;
    string _url;
public:
    AxisOperation ( const axutil_env_t * axis_env, struct axis2_msg_ctx * msg_ctx ) {
        
	  	//TODO: unprotected code: to protect pointers access
	  
        axis2_op_ctx_t *operation_ctx = axis2_msg_ctx_get_op_ctx ( msg_ctx, axis_env );
        axis2_op_t *operation = axis2_op_ctx_get_op ( operation_ctx, axis_env );
        axutil_qname_t *op_qname = ( axutil_qname_t * ) axis2_op_get_qname ( operation, axis_env );
        _operation_name = axutil_qname_get_localpart ( op_qname, axis_env );
        _service_name = axutil_qname_get_prefix ( op_qname, axis_env );
        _full_name = _service_name + "." + _operation_name;

		axis2_endpoint_ref_t* endpoint_ref = axis2_msg_ctx_get_from (msg_ctx, axis_env);
		if (endpoint_ref) {
		  const axis2_char_t *url = axis2_endpoint_ref_get_address(endpoint_ref, axis_env);
		  if (url) {
			_url = url;
		  }
		}
    }

    virtual const string& getServiceName() const {
        return _service_name;
    }
    virtual const string& getName() const {
        return _full_name;
    }
    virtual const string& getOperationName() const {
        return _operation_name;
    }
    virtual const string& getURL() const {
        return _url;
    }
};

class AxisInFlowContext: public InFlowContext {
    AxisCookieWrapper _cookies;
    AxisEnvironmentWrapper _environment;
    AxisProviderStoreFacility _providerStore;
    AxisOperation _operation;
    XmlParams _params;

public:
    AxisInFlowContext ( const axutil_env_t * axis_env,
                        struct axis2_msg_ctx * msg_ctx ) :
        _cookies ( axis_env,msg_ctx ),
        _environment ( axis_env,msg_ctx ),
        _providerStore ( axis_env,msg_ctx ),
        _operation ( axis_env,msg_ctx ),
        _params ( axis_env,msg_ctx ) {}

    virtual Environment& getCookies() {
        return _cookies;
    }
    virtual Environment& getEnvironment() {
        return _environment;
    }
    virtual ProviderStore& getProviderStore() {
        return _providerStore;
    }
    virtual OperationInfo& getOperation() {
        return _operation;
    }
    virtual anubis::webservice::Params& getParams() {
        return _params;
    };
};

class AxisOutFlowContext: public OutFlowContext {
    AxisEnvironmentWrapper _environment;
    AxisProviderStoreFacility _providerStore;
    AxisOperation _operation;
public:
    AxisOutFlowContext ( const axutil_env_t * axis_env,
                         struct axis2_msg_ctx * msg_ctx ) :
        _environment ( axis_env,msg_ctx ),
        _providerStore ( axis_env, msg_ctx ),
        _operation ( axis_env,msg_ctx ) {}

    virtual Environment& getEnvironment() {
        return _environment;
    }
    virtual ProviderStore& getProviderStore() {
        return _providerStore;
    }
    virtual OperationInfo& getOperation() {
        return _operation;
    }
};

class ModuleLoader {
    list <void *> _soHandles;
public:
    void load ( const string& soFilepath ) {
        //opening the lib triggers the static registration on the module
        void* handle = dlopen ( soFilepath.c_str(), RTLD_NOW | RTLD_GLOBAL );

        if ( !handle ) {
					cerr << "Cannot open library ["<< soFilepath <<"]. ("<< dlerror() <<")" << endl;
					return;
        }
        _soHandles.push_back ( handle );
    }

    void unloadAll() {
        list< void* >::iterator it = _soHandles.begin();
        for ( ; it != _soHandles.end(); ++it ) {
            dlclose ( *it );
        }
    }
};
//Global module registry
ModuleLoader mloader;

#ifdef __cplusplus
extern "C"
{
#endif

    axis2_status_t AXIS2_CALL
    axutil_module_in_handler_invoke (
        struct axis2_handler * /*handler*/,
        const axutil_env_t * env,
        struct axis2_msg_ctx * msg_ctx ) {

        AxisInFlowContext flowContext ( env, msg_ctx );
        const map< string, WebModule* > & storeMap = WebModuleStore::getInstance().getStore();
        map< string, WebModule* >::const_iterator it = storeMap.begin();
        try {
            for ( ; it != storeMap.end(); ++it ) {
                if ( it->second->inFlow ( flowContext ) != WebModule::OK ) {
                    return AXIS2_FAILURE;
                }
            }
        } catch ( ModuleAuthenticationException &ex ) {
					cerr << "Authentication IN module exception error :" << flowContext.getOperation().getServiceName()
                              << "/" << flowContext.getOperation().getOperationName() << ":" << ex.what() << endl;
            axis2_msg_ctx_set_status_code ( msg_ctx, env, 401 );
            return AXIS2_FAILURE;
        } catch ( ModuleAuthorizationException &ex ) {
            cerr << "Authorization IN module exception error :" << flowContext.getOperation().getServiceName()
                              << "/" << flowContext.getOperation().getOperationName() << ":" << ex.what() << endl;
            axis2_msg_ctx_set_status_code ( msg_ctx, env, 403 );
            return AXIS2_FAILURE;
        } catch ( ModuleException &ex ) {
            cerr << "General IN module exception error :" << flowContext.getOperation().getServiceName()
                              << "/" << flowContext.getOperation().getOperationName() << ":" << ex.what() << endl;

            return AXIS2_FAILURE;
        }
        return AXIS2_SUCCESS;
    }

    AXIS2_EXTERN axis2_handler_t *AXIS2_CALL
    axutil_module_in_handler_create (
        const axutil_env_t * env,
        axutil_string_t * /*name*/ ) {
        axis2_handler_t *handler = NULL;

        AXIS2_ENV_CHECK ( env, NULL );

        handler = axis2_handler_create ( env );
        if ( !handler ) {
            return NULL;
        }

        axis2_handler_set_invoke ( handler, env, axutil_module_in_handler_invoke );

        return handler;
    }

    axis2_status_t AXIS2_CALL
    axutil_module_out_handler_invoke (
        struct axis2_handler * /*handler*/,
        const axutil_env_t * env,
        struct axis2_msg_ctx * msg_ctx ) {
        AxisOutFlowContext flowContext ( env, msg_ctx );
        const map< string, WebModule* > & storeMap = WebModuleStore::getInstance().getStore();
        map< string, WebModule* >::const_iterator it = storeMap.begin();
        try {
            for ( ; it != storeMap.end(); ++it ) {
                if ( it->second->outFlow ( flowContext ) != WebModule::OK ) {
                    return AXIS2_FAILURE;
                }
            }
        } catch ( ModuleException &ex ) {
            cerr << "General OUT module exception error:" << flowContext.getOperation().getServiceName()
                              << "/" << flowContext.getOperation().getOperationName() << ":" << ex.what() << endl;
            return AXIS2_FAILURE;
        }
        return AXIS2_SUCCESS;
    }

    AXIS2_EXTERN axis2_handler_t *AXIS2_CALL
    axutil_module_out_handler_create (
        const axutil_env_t * env,
        axutil_string_t * /*name*/ ) {
        axis2_handler_t *handler = NULL;

        AXIS2_ENV_CHECK ( env, NULL );

        handler = axis2_handler_create ( env );
        if ( !handler ) {
            return NULL;
        }

        axis2_handler_set_invoke ( handler, env, axutil_module_out_handler_invoke );

        return handler;
    }

    axis2_status_t AXIS2_CALL
    axis2_mod_module_shutdown (
        axis2_module_t * module,
        const axutil_env_t * env ) {
        mloader.unloadAll();

        if ( module->handler_create_func_map ) {
            axutil_hash_free ( module->handler_create_func_map, env );
        }

        if ( module ) {
            AXIS2_FREE ( env->allocator, module );
        }


        return AXIS2_SUCCESS;
    }

    axis2_status_t AXIS2_CALL
    axis2_mod_module_init (
        axis2_module_t * /*module*/,
        const axutil_env_t * env,
        axis2_conf_ctx_t * /*conf_ctx*/,
        axis2_module_desc_t * /*module_desc*/ ) {
        //TODO: do we need to read from a file to preserve loading order??
        const string glob_pattern ( "/opt/wps/modules/libwps_module_*.so" );
        glob_t gl;
        if ( 0 == glob ( glob_pattern.c_str(), 0, NULL, &gl ) ) {
            for ( size_t i = 0; i < gl.gl_pathc; ++i ) {
                string line ( "Loading module in " );
                line.append ( gl.gl_pathv[i] );
                AXIS2_LOG_INFO ( env->log, line.c_str() );
                mloader.load ( gl.gl_pathv[i] );
            }
            globfree ( &gl );
        }
        return AXIS2_SUCCESS;
    }

    axis2_status_t AXIS2_CALL
    axutil_module_out_fault_handler_invoke (
        struct axis2_handler * /*handler*/,
        const axutil_env_t * env,
        struct axis2_msg_ctx * msg_ctx ) {
        AXIS2_LOG_INFO ( env->log, "[Generic Module] out FAULT handler" );
        AxisOutFlowContext flowContext ( env, msg_ctx );
        const map< string, WebModule* > & storeMap = WebModuleStore::getInstance().getStore();
        map< string, WebModule* >::const_iterator it = storeMap.begin();
				cerr << "Running outflowFault" << endl;
        try {
            for ( ; it != storeMap.end(); ++it ) {
                if ( it->second->outFlowFault ( flowContext ) != WebModule::OK ) {
                    cerr << "General OUT FAULT module error:" << flowContext.getOperation().getServiceName()
                                      << "/" << flowContext.getOperation().getOperationName() << endl;

                    return AXIS2_FAILURE;
                }
            }
        } catch ( ModuleException &ex ) {
            cerr << "General OUT FAULT module exception error:" << flowContext.getOperation().getServiceName()
                              << "/" << flowContext.getOperation().getOperationName() << ":" << ex.what() << endl;
            return AXIS2_FAILURE;
        }
        return AXIS2_SUCCESS;
    }

    AXIS2_EXTERN axis2_handler_t *AXIS2_CALL
    axutil_module_out_fault_handler_create (
        const axutil_env_t * env,
        axutil_string_t * /*name*/ ) {
        axis2_handler_t *handler = NULL;

        AXIS2_ENV_CHECK ( env, NULL );

        handler = axis2_handler_create ( env );
        if ( !handler ) {
            return NULL;
        }
        axis2_handler_set_invoke ( handler, env, axutil_module_out_fault_handler_invoke );
        return handler;
    }

    axis2_status_t AXIS2_CALL
    axis2_mod_module_fill_handler_create_func_map (
        axis2_module_t * module,
        const axutil_env_t * env ) {
        AXIS2_ENV_CHECK ( env, AXIS2_FAILURE );

        module->handler_create_func_map = axutil_hash_make ( env );
        if ( !module->handler_create_func_map ) {
            AXIS2_ERROR_SET ( env->error, AXIS2_ERROR_NO_MEMORY, AXIS2_FAILURE );
            return AXIS2_FAILURE;
        }

        /* add in handler */
        axutil_hash_set ( module->handler_create_func_map, "ModuleInHandler",
                          AXIS2_HASH_KEY_STRING, ( const void * ) axutil_module_in_handler_create );

        /* add out handler, for successfull authentications */
        axutil_hash_set ( module->handler_create_func_map, "ModuleOutHandler",
                          AXIS2_HASH_KEY_STRING, ( const void * ) axutil_module_out_handler_create );

        /* add out handler, for failed authentications */
        axutil_hash_set ( module->handler_create_func_map, "ModuleOutFaultHandler",
                          AXIS2_HASH_KEY_STRING, ( const void * ) axutil_module_out_fault_handler_create );

        return AXIS2_SUCCESS;
    }

    /**
     * Module operations struct variable with functions assigned to members
     */
    static const axis2_module_ops_t module_module_ops_var = {
        axis2_mod_module_init,
        axis2_mod_module_shutdown,
        axis2_mod_module_fill_handler_create_func_map
    };

    axis2_module_t *
    axis2_mod_module_create (
        const axutil_env_t * env ) {
        axis2_module_t *module = NULL;
        module = ( axis2_module_t* ) AXIS2_MALLOC ( env->allocator, sizeof ( axis2_module_t ) );
        /* initialize operations */
        module->ops = &module_module_ops_var;
        return module;
    }

    /**
     * Following functions are expected to be there in the module lib
     * that helps to create and remove module instances
    */

    AXIS2_EXPORT int
    axis2_get_instance (
        axis2_module_t ** inst,
        const axutil_env_t * env ) {
        *inst = axis2_mod_module_create ( env );
        if ( ! ( *inst ) ) {
            return AXIS2_FAILURE;
        }

        return AXIS2_SUCCESS;
    }

    AXIS2_EXPORT int
    axis2_remove_instance (
        axis2_module_t * inst,
        const axutil_env_t * env ) {
        axis2_status_t status = AXIS2_FAILURE;
        if ( inst ) {
            status = axis2_mod_module_shutdown ( inst, env );
        }
        return status;
    }

#ifdef __cplusplus
}
#endif
