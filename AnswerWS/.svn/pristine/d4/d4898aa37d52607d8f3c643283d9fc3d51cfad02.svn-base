#include "anubis/webservice/webmodule/Authentication.hh"

#include <libanubis-config/AnubisConfiguration.hh>

#include <wps/users/UserSession.hh>
#include <wps/users/User.hh>
#include <fstream>

#include <boost/algorithm/string/split.hpp>


using namespace std;

namespace anubis {
namespace webservice {
namespace webmodule {

//XXX: HARD-CODED POINTS: 2

Authentication::Authentication() {
    _timeout_secs = 5;

	 anubis::config::AnubisConfiguration &conf = anubis::config::AnubisConfiguration::GetInstance("/opt/wps/etc/wps.conf");
	 _timeout_secs = conf.get("memcache.timeout_secs", _timeout_secs);

	std::string memc_config = conf.get<std::string>("memcache.hostname");
	boost::iter_split ( _memcacheHosts, memc_config, boost::algorithm::first_finder ( ";", boost::algorithm::is_equal() ) );


	for ( std::vector< std::string >::const_iterator it = _memcacheHosts.begin(); it != _memcacheHosts.end(); ++it ) {

        std::size_t idx = it->rfind ( ":" );
        if ( idx != std::string::npos ) {
            try {
                std::string hostName = it->substr ( 0, idx );
                int port = boost::lexical_cast<int> ( it->substr ( idx+1 ) );
                _servers.push_back ( server_location_t ( hostName, port ) );
            } catch ( std::out_of_range ) {
                cerr << "Invalid memcache hostname:port ["<< *it <<"] "<< endl;
            }
        } else {
            _servers.push_back ( server_location_t ( *it, 11211 ) );
        }
    }

    setCacheServers();

    //TODO: Read from config
    std::ifstream fin ( "/opt/wps/etc/roles_latice" );
    if ( !fin ) {
        throw std::runtime_error ( "Could not open Roles Latice file" );
    }
    _pdp = RBAC::PDP::fromTXT ( fin );
    fin.close();
}

void Authentication::setCacheServers() {

    if ( _memcacheServer.get() == NULL ) {

        _memcacheServer = std::auto_ptr<memcache::Memcache> ( new memcache::Memcache() );
        _memcacheServer->setBehavior ( MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT, _timeout_secs ); //microseconds
        _memcacheServer->setBehavior ( MEMCACHED_BEHAVIOR_SND_TIMEOUT, _timeout_secs ); //microseconds
        _memcacheServer->setBehavior ( MEMCACHED_BEHAVIOR_RCV_TIMEOUT, _timeout_secs ); //microseconds
        _memcacheServer->setBehavior ( MEMCACHED_BEHAVIOR_RETRY_TIMEOUT, _timeout_secs ); //microseconds
        _memcacheServer->setBehavior ( MEMCACHED_BEHAVIOR_TCP_NODELAY, 1 ); //microseconds

    }

    if ( _memcacheServer.get() != NULL ) {
//         if ( _memcacheServer->getServersList().empty() ) {
            for ( std::list<server_location_t>::const_iterator it = _servers.begin(); it != _servers.end(); ++it ) {
                _memcacheServer->removeServer ( it->first, it->second );
                if ( ! _memcacheServer->addServer ( it->first, it->second ) ) {
                    cerr << " Failed to add server " << it->first << ":" << it->second << endl;
                }

            }
//         }
    }
}

anubis::webservice::WebModule::FlowStatus Authentication::inFlow ( InFlowContext &context ) {



    try {
        RBAC::User rbacuser ( "" );
		//Assuming no session is defined => assuming unauthenticated user
		rbacuser.setRole ( _pdp->getRole ( "guest" ) );
		std::string username = "anonymous";
        
		//TODO: FUGLY  -  remove when refactogin audit
        if ( context.getCookies().contains ( "session" ) ) {
            std::string sessionID ( context.getCookies().at ( "session" ) );
			// let's try to access session
			try 
			{
				setCacheServers();
				wps::users::UserSession uSession ( sessionID, *_memcacheServer );
				
				// is uSession is retrieved, everything should be fine
				rbacuser = RBAC::User ( uSession.getUser().getUserId() );
				rbacuser.setRole ( _pdp->getRole ( uSession.getUser().getRoleType() ) );
				username = uSession.getUser().getUsername();
			}
			catch(...) 
			{
				// if session retrieve fails, let the flow continue as anonymous/guest
			}

        }
        context.getProviderStore().addProvider ( "user", rbacuser );
        context.getProviderStore().addProvider ( "username", username );
        ///XXX-DEBUG: cerr << "Authentication for :" << context.getOperation().getOperationName() << endl;
    } catch ( std::runtime_error &ex ) {
        throw ModuleAuthenticationException ( ex.what() );
    }
    return OK;
}

anubis::webservice::WebModule::FlowStatus Authentication::outFlow ( OutFlowContext &/*context*/ ) {
    //We currently have no outFlow handling
    return OK;
}

anubis::webservice::WebModule::FlowStatus Authentication::outFlowFault ( OutFlowContext &/*context*/ ) {
    //We currently have no outFlow Fault handling
    return OK;
}

RBAC::PDP *Authentication::_pdp;

static RegisterWebModule<Authentication> _register("Authentication");

}
}
}
